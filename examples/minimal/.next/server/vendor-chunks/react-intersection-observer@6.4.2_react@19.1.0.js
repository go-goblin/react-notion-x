"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-intersection-observer@6.4.2_react@19.1.0";
exports.ids = ["vendor-chunks/react-intersection-observer@6.4.2_react@19.1.0"];
exports.modules = {

/***/ "(pages-dir-node)/../../node_modules/.pnpm/react-intersection-observer@6.4.2_react@19.1.0/node_modules/react-intersection-observer/dist/react-intersection-observer.cjs.js":
/*!****************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/react-intersection-observer@6.4.2_react@19.1.0/node_modules/react-intersection-observer/dist/react-intersection-observer.cjs.js ***!
  \****************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar _extends = _interopDefault(__webpack_require__(/*! @babel/runtime/helpers/extends */ \"(pages-dir-node)/../../node_modules/.pnpm/@babel+runtime@7.27.6/node_modules/@babel/runtime/helpers/extends.js\"));\nvar _objectWithoutPropertiesLoose = _interopDefault(__webpack_require__(/*! @babel/runtime/helpers/objectWithoutPropertiesLoose */ \"(pages-dir-node)/../../node_modules/.pnpm/@babel+runtime@7.27.6/node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js\"));\nvar _inheritsLoose = _interopDefault(__webpack_require__(/*! @babel/runtime/helpers/inheritsLoose */ \"(pages-dir-node)/../../node_modules/.pnpm/@babel+runtime@7.27.6/node_modules/@babel/runtime/helpers/inheritsLoose.js\"));\nvar _assertThisInitialized = _interopDefault(__webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"(pages-dir-node)/../../node_modules/.pnpm/@babel+runtime@7.27.6/node_modules/@babel/runtime/helpers/assertThisInitialized.js\"));\nvar _defineProperty = _interopDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(pages-dir-node)/../../node_modules/.pnpm/@babel+runtime@7.27.6/node_modules/@babel/runtime/helpers/defineProperty.js\"));\nvar React = __webpack_require__(/*! react */ \"react\");\nvar invariant = _interopDefault(__webpack_require__(/*! invariant */ \"(pages-dir-node)/../../node_modules/.pnpm/invariant@2.2.4/node_modules/invariant/invariant.js\"));\n\nvar INSTANCE_MAP = new Map();\nvar OBSERVER_MAP = new Map();\n/**\n * Monitor element, and trigger callback when element becomes visible\n * @param element {HTMLElement}\n * @param callback {Function} Called with inView\n * @param options {Object} InterSection observer options\n * @param options.threshold {Number} Number between 0 and 1, indicating how much of the element should be visible before triggering\n * @param options.root {HTMLElement} It should have a unique id or data-intersection-id in order for the Observer to reused.\n * @param options.rootMargin {String} The CSS margin to apply to the root element.\n * @param rootId {String} Unique identifier for the root element, to enable reusing the IntersectionObserver\n */\n\nfunction observe(element, callback, options, rootId) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  // Validate that the element is not being used in another <Observer />\n  invariant(!INSTANCE_MAP.has(element), \"react-intersection-observer: Trying to observe %s, but it's already being observed by another instance.\\nMake sure the `ref` is only used by a single <Observer /> instance.\\n\\n%s\", element); // IntersectionObserver needs a threshold to trigger, so set it to 0 if it's not defined.\n  // Modify the options object, since it's used in the onChange handler.\n\n  if (!options.threshold) options.threshold = 0;\n  var _options = options,\n      root = _options.root,\n      rootMargin = _options.rootMargin,\n      threshold = _options.threshold;\n  if (!element || !callback) return;\n  var observerId = rootMargin ? threshold.toString() + \"_\" + rootMargin : threshold.toString();\n\n  if (root) {\n    observerId = rootId ? rootId + \"_\" + observerId : null;\n  }\n\n  var observerInstance = observerId ? OBSERVER_MAP.get(observerId) : null;\n\n  if (!observerInstance) {\n    observerInstance = new IntersectionObserver(onChange, options);\n    if (observerId) OBSERVER_MAP.set(observerId, observerInstance);\n  }\n\n  var instance = {\n    callback: callback,\n    visible: false,\n    options: options,\n    observerId: observerId,\n    observer: !observerId ? observerInstance : undefined\n  };\n  INSTANCE_MAP.set(element, instance);\n  observerInstance.observe(element);\n  return instance;\n}\n/**\n * Stop observing an element. If an element is removed from the DOM or otherwise destroyed,\n * make sure to call this method.\n * @param element {HTMLElement}\n */\n\nfunction unobserve(element) {\n  if (!element) return;\n  var instance = INSTANCE_MAP.get(element);\n\n  if (instance) {\n    var observerId = instance.observerId,\n        observer = instance.observer;\n    var observerInstance = observerId ? OBSERVER_MAP.get(observerId) : observer;\n\n    if (observerInstance) {\n      observerInstance.unobserve(element);\n    } // Check if we are still observing any elements with the same threshold.\n\n\n    var itemsLeft = false;\n\n    if (observerId) {\n      INSTANCE_MAP.forEach(function (item, key) {\n        if (item && item.observerId === observerId && key !== element) {\n          itemsLeft = true;\n        }\n      });\n    }\n\n    if (observerInstance && !itemsLeft) {\n      // No more elements to observe for threshold, disconnect observer\n      observerInstance.disconnect();\n      OBSERVER_MAP.delete(observerId);\n    } // Remove reference to element\n\n\n    INSTANCE_MAP.delete(element);\n  }\n}\n\nfunction onChange(changes) {\n  changes.forEach(function (intersection) {\n    var isIntersecting = intersection.isIntersecting,\n        intersectionRatio = intersection.intersectionRatio,\n        target = intersection.target;\n    var instance = INSTANCE_MAP.get(target); // Firefox can report a negative intersectionRatio when scrolling.\n\n    if (instance && intersectionRatio >= 0) {\n      var options = instance.options;\n      var _inView = false;\n\n      if (Array.isArray(options.threshold)) {\n        // If threshold is an array, check if any of them intersects. This just triggers the onChange event multiple times.\n        _inView = options.threshold.some(function (threshold) {\n          return instance.visible ? intersectionRatio > threshold : intersectionRatio >= threshold;\n        });\n      } else if (options.threshold !== undefined) {\n        // Trigger on 0 ratio only when not visible. This is fallback for browsers without isIntersecting support\n        _inView = instance.visible ? intersectionRatio > options.threshold : intersectionRatio >= options.threshold;\n      }\n\n      if (isIntersecting !== undefined) {\n        // If isIntersecting is defined, ensure that the element is actually intersecting.\n        // Otherwise it reports a threshold of 0\n        _inView = _inView && isIntersecting;\n      }\n\n      instance.visible = _inView;\n      instance.callback(_inView, intersectionRatio);\n    }\n  });\n}\n\nfunction useInView(ref, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  // $FlowFixMe - useState is not exposed in React Flow lib yet\n  var _React$useState = React.useState(false),\n      isInView = _React$useState[0],\n      setInView = _React$useState[1]; // $FlowFixMe - useEffect is not exposed in React Flow lib yet\n\n\n  React.useEffect(function () {\n    if (ref.current) {\n      observe(ref.current, function (inView) {\n        setInView(inView);\n\n        if (inView && options.triggerOnce) {\n          // If it should only trigger once, unobserve the element after it's inView\n          unobserve(ref.current);\n        }\n      }, {\n        threshold: options.threshold,\n        root: options.root,\n        rootMargin: options.rootMargin\n      }, options.rootId);\n    }\n\n    return function () {\n      unobserve(ref.current);\n    };\n  }, [options.threshold, options.root, options.rootMargin, options.rootId]);\n  return isInView;\n}\n\n/**\n * Monitors scroll, and triggers the children function with updated props\n *\n <InView>\n {({inView, ref}) => (\n   <h1 ref={ref}>{`${inView}`}</h1>\n )}\n </InView>\n */\nvar InView =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inheritsLoose(InView, _React$Component);\n\n  function InView() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"state\", {\n      inView: false,\n      intersectionRatio: 0\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"node\", null);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleNode\", function (node) {\n      if (_this.node) unobserve(_this.node);\n      _this.node = node;\n\n      _this.observeNode();\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleChange\", function (inView, intersectionRatio) {\n      _this.setState({\n        inView: inView,\n        intersectionRatio: intersectionRatio\n      });\n\n      if (_this.props.onChange) {\n        _this.props.onChange(inView, intersectionRatio);\n      }\n    });\n\n    return _this;\n  }\n\n  var _proto = InView.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    if (true) {\n      if (this.props.hasOwnProperty('render')) {\n        console.warn(\"react-intersection-observer: \\\"render\\\" is deprecated, and should be replaced with \\\"children\\\"\", this.node);\n      }\n\n      invariant(this.node, \"react-intersection-observer: No DOM node found. Make sure you forward \\\"ref\\\" to the root DOM element you want to observe.\");\n    }\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    // If a IntersectionObserver option changed, reinit the observer\n    if (prevProps.rootMargin !== this.props.rootMargin || prevProps.root !== this.props.root || prevProps.threshold !== this.props.threshold) {\n      unobserve(this.node);\n      this.observeNode();\n    }\n\n    if (prevState.inView !== this.state.inView) {\n      if (this.state.inView && this.props.triggerOnce) {\n        unobserve(this.node);\n        this.node = null;\n      }\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    if (this.node) {\n      unobserve(this.node);\n      this.node = null;\n    }\n  };\n\n  _proto.observeNode = function observeNode() {\n    if (!this.node) return;\n    var _this$props = this.props,\n        threshold = _this$props.threshold,\n        root = _this$props.root,\n        rootMargin = _this$props.rootMargin,\n        rootId = _this$props.rootId;\n    observe(this.node, this.handleChange, {\n      threshold: threshold,\n      root: root,\n      rootMargin: rootMargin\n    }, rootId);\n  };\n\n  _proto.render = function render() {\n    var _this$props2 = this.props,\n        children = _this$props2.children,\n        render = _this$props2.render,\n        tag = _this$props2.tag,\n        triggerOnce = _this$props2.triggerOnce,\n        threshold = _this$props2.threshold,\n        root = _this$props2.root,\n        rootId = _this$props2.rootId,\n        rootMargin = _this$props2.rootMargin,\n        props = _objectWithoutPropertiesLoose(_this$props2, [\"children\", \"render\", \"tag\", \"triggerOnce\", \"threshold\", \"root\", \"rootId\", \"rootMargin\"]);\n\n    var _this$state = this.state,\n        inView = _this$state.inView,\n        intersectionRatio = _this$state.intersectionRatio;\n    var renderMethod = children || render;\n\n    if (typeof renderMethod === 'function') {\n      return renderMethod({\n        inView: inView,\n        intersectionRatio: intersectionRatio,\n        ref: this.handleNode\n      });\n    }\n\n    return React.createElement(tag || 'div', _extends({\n      ref: this.handleNode\n    }, props), children);\n  };\n\n  return InView;\n}(React.Component);\n\n_defineProperty(InView, \"defaultProps\", {\n  threshold: 0,\n  triggerOnce: false\n});\n\nexports.InView = InView;\nexports[\"default\"] = InView;\nexports.useInView = useInView;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtaW50ZXJzZWN0aW9uLW9ic2VydmVyQDYuNC4yX3JlYWN0QDE5LjEuMC9ub2RlX21vZHVsZXMvcmVhY3QtaW50ZXJzZWN0aW9uLW9ic2VydmVyL2Rpc3QvcmVhY3QtaW50ZXJzZWN0aW9uLW9ic2VydmVyLmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELGdDQUFnQzs7QUFFaEMsK0JBQStCLG1CQUFPLENBQUMsc0pBQWdDO0FBQ3ZFLG9EQUFvRCxtQkFBTyxDQUFDLGdNQUFxRDtBQUNqSCxxQ0FBcUMsbUJBQU8sQ0FBQyxrS0FBc0M7QUFDbkYsNkNBQTZDLG1CQUFPLENBQUMsa0xBQThDO0FBQ25HLHNDQUFzQyxtQkFBTyxDQUFDLG9LQUF1QztBQUNyRixZQUFZLG1CQUFPLENBQUMsb0JBQU87QUFDM0IsZ0NBQWdDLG1CQUFPLENBQUMsZ0hBQVc7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLG9CQUFvQixVQUFVO0FBQzlCLG1CQUFtQixRQUFRO0FBQzNCLDZCQUE2QixRQUFRO0FBQ3JDLHdCQUF3QixhQUFhO0FBQ3JDLDhCQUE4QixRQUFRO0FBQ3RDLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd09BQXdPO0FBQ3hPOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7OztBQUd0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsWUFBWTtBQUNoQixZQUFZLElBQUksRUFBRSxHQUFHLE9BQU8sRUFBRTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGNBQWM7QUFDZCxrQkFBZTtBQUNmLGlCQUFpQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxrdWRyeVxcRG9jdW1lbnRzXFxSZWFjdFByb2plY3RzXFxyZWFjdC1ub3Rpb24teFxcbm9kZV9tb2R1bGVzXFwucG5wbVxccmVhY3QtaW50ZXJzZWN0aW9uLW9ic2VydmVyQDYuNC4yX3JlYWN0QDE5LjEuMFxcbm9kZV9tb2R1bGVzXFxyZWFjdC1pbnRlcnNlY3Rpb24tb2JzZXJ2ZXJcXGRpc3RcXHJlYWN0LWludGVyc2VjdGlvbi1vYnNlcnZlci5janMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIF9leHRlbmRzID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcycpKTtcbnZhciBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UnKSk7XG52YXIgX2luaGVyaXRzTG9vc2UgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c0xvb3NlJykpO1xudmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQnKSk7XG52YXIgX2RlZmluZVByb3BlcnR5ID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHknKSk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGludmFyaWFudCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdpbnZhcmlhbnQnKSk7XG5cbnZhciBJTlNUQU5DRV9NQVAgPSBuZXcgTWFwKCk7XG52YXIgT0JTRVJWRVJfTUFQID0gbmV3IE1hcCgpO1xuLyoqXG4gKiBNb25pdG9yIGVsZW1lbnQsIGFuZCB0cmlnZ2VyIGNhbGxiYWNrIHdoZW4gZWxlbWVudCBiZWNvbWVzIHZpc2libGVcbiAqIEBwYXJhbSBlbGVtZW50IHtIVE1MRWxlbWVudH1cbiAqIEBwYXJhbSBjYWxsYmFjayB7RnVuY3Rpb259IENhbGxlZCB3aXRoIGluVmlld1xuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0gSW50ZXJTZWN0aW9uIG9ic2VydmVyIG9wdGlvbnNcbiAqIEBwYXJhbSBvcHRpb25zLnRocmVzaG9sZCB7TnVtYmVyfSBOdW1iZXIgYmV0d2VlbiAwIGFuZCAxLCBpbmRpY2F0aW5nIGhvdyBtdWNoIG9mIHRoZSBlbGVtZW50IHNob3VsZCBiZSB2aXNpYmxlIGJlZm9yZSB0cmlnZ2VyaW5nXG4gKiBAcGFyYW0gb3B0aW9ucy5yb290IHtIVE1MRWxlbWVudH0gSXQgc2hvdWxkIGhhdmUgYSB1bmlxdWUgaWQgb3IgZGF0YS1pbnRlcnNlY3Rpb24taWQgaW4gb3JkZXIgZm9yIHRoZSBPYnNlcnZlciB0byByZXVzZWQuXG4gKiBAcGFyYW0gb3B0aW9ucy5yb290TWFyZ2luIHtTdHJpbmd9IFRoZSBDU1MgbWFyZ2luIHRvIGFwcGx5IHRvIHRoZSByb290IGVsZW1lbnQuXG4gKiBAcGFyYW0gcm9vdElkIHtTdHJpbmd9IFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgcm9vdCBlbGVtZW50LCB0byBlbmFibGUgcmV1c2luZyB0aGUgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcbiAqL1xuXG5mdW5jdGlvbiBvYnNlcnZlKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zLCByb290SWQpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIHRoYXQgdGhlIGVsZW1lbnQgaXMgbm90IGJlaW5nIHVzZWQgaW4gYW5vdGhlciA8T2JzZXJ2ZXIgLz5cbiAgaW52YXJpYW50KCFJTlNUQU5DRV9NQVAuaGFzKGVsZW1lbnQpLCBcInJlYWN0LWludGVyc2VjdGlvbi1vYnNlcnZlcjogVHJ5aW5nIHRvIG9ic2VydmUgJXMsIGJ1dCBpdCdzIGFscmVhZHkgYmVpbmcgb2JzZXJ2ZWQgYnkgYW5vdGhlciBpbnN0YW5jZS5cXG5NYWtlIHN1cmUgdGhlIGByZWZgIGlzIG9ubHkgdXNlZCBieSBhIHNpbmdsZSA8T2JzZXJ2ZXIgLz4gaW5zdGFuY2UuXFxuXFxuJXNcIiwgZWxlbWVudCk7IC8vIEludGVyc2VjdGlvbk9ic2VydmVyIG5lZWRzIGEgdGhyZXNob2xkIHRvIHRyaWdnZXIsIHNvIHNldCBpdCB0byAwIGlmIGl0J3Mgbm90IGRlZmluZWQuXG4gIC8vIE1vZGlmeSB0aGUgb3B0aW9ucyBvYmplY3QsIHNpbmNlIGl0J3MgdXNlZCBpbiB0aGUgb25DaGFuZ2UgaGFuZGxlci5cblxuICBpZiAoIW9wdGlvbnMudGhyZXNob2xkKSBvcHRpb25zLnRocmVzaG9sZCA9IDA7XG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICByb290ID0gX29wdGlvbnMucm9vdCxcbiAgICAgIHJvb3RNYXJnaW4gPSBfb3B0aW9ucy5yb290TWFyZ2luLFxuICAgICAgdGhyZXNob2xkID0gX29wdGlvbnMudGhyZXNob2xkO1xuICBpZiAoIWVsZW1lbnQgfHwgIWNhbGxiYWNrKSByZXR1cm47XG4gIHZhciBvYnNlcnZlcklkID0gcm9vdE1hcmdpbiA/IHRocmVzaG9sZC50b1N0cmluZygpICsgXCJfXCIgKyByb290TWFyZ2luIDogdGhyZXNob2xkLnRvU3RyaW5nKCk7XG5cbiAgaWYgKHJvb3QpIHtcbiAgICBvYnNlcnZlcklkID0gcm9vdElkID8gcm9vdElkICsgXCJfXCIgKyBvYnNlcnZlcklkIDogbnVsbDtcbiAgfVxuXG4gIHZhciBvYnNlcnZlckluc3RhbmNlID0gb2JzZXJ2ZXJJZCA/IE9CU0VSVkVSX01BUC5nZXQob2JzZXJ2ZXJJZCkgOiBudWxsO1xuXG4gIGlmICghb2JzZXJ2ZXJJbnN0YW5jZSkge1xuICAgIG9ic2VydmVySW5zdGFuY2UgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIob25DaGFuZ2UsIG9wdGlvbnMpO1xuICAgIGlmIChvYnNlcnZlcklkKSBPQlNFUlZFUl9NQVAuc2V0KG9ic2VydmVySWQsIG9ic2VydmVySW5zdGFuY2UpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0ge1xuICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgIG9ic2VydmVySWQ6IG9ic2VydmVySWQsXG4gICAgb2JzZXJ2ZXI6ICFvYnNlcnZlcklkID8gb2JzZXJ2ZXJJbnN0YW5jZSA6IHVuZGVmaW5lZFxuICB9O1xuICBJTlNUQU5DRV9NQVAuc2V0KGVsZW1lbnQsIGluc3RhbmNlKTtcbiAgb2JzZXJ2ZXJJbnN0YW5jZS5vYnNlcnZlKGVsZW1lbnQpO1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG4vKipcbiAqIFN0b3Agb2JzZXJ2aW5nIGFuIGVsZW1lbnQuIElmIGFuIGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00gb3Igb3RoZXJ3aXNlIGRlc3Ryb3llZCxcbiAqIG1ha2Ugc3VyZSB0byBjYWxsIHRoaXMgbWV0aG9kLlxuICogQHBhcmFtIGVsZW1lbnQge0hUTUxFbGVtZW50fVxuICovXG5cbmZ1bmN0aW9uIHVub2JzZXJ2ZShlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkgcmV0dXJuO1xuICB2YXIgaW5zdGFuY2UgPSBJTlNUQU5DRV9NQVAuZ2V0KGVsZW1lbnQpO1xuXG4gIGlmIChpbnN0YW5jZSkge1xuICAgIHZhciBvYnNlcnZlcklkID0gaW5zdGFuY2Uub2JzZXJ2ZXJJZCxcbiAgICAgICAgb2JzZXJ2ZXIgPSBpbnN0YW5jZS5vYnNlcnZlcjtcbiAgICB2YXIgb2JzZXJ2ZXJJbnN0YW5jZSA9IG9ic2VydmVySWQgPyBPQlNFUlZFUl9NQVAuZ2V0KG9ic2VydmVySWQpIDogb2JzZXJ2ZXI7XG5cbiAgICBpZiAob2JzZXJ2ZXJJbnN0YW5jZSkge1xuICAgICAgb2JzZXJ2ZXJJbnN0YW5jZS51bm9ic2VydmUoZWxlbWVudCk7XG4gICAgfSAvLyBDaGVjayBpZiB3ZSBhcmUgc3RpbGwgb2JzZXJ2aW5nIGFueSBlbGVtZW50cyB3aXRoIHRoZSBzYW1lIHRocmVzaG9sZC5cblxuXG4gICAgdmFyIGl0ZW1zTGVmdCA9IGZhbHNlO1xuXG4gICAgaWYgKG9ic2VydmVySWQpIHtcbiAgICAgIElOU1RBTkNFX01BUC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBrZXkpIHtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vYnNlcnZlcklkID09PSBvYnNlcnZlcklkICYmIGtleSAhPT0gZWxlbWVudCkge1xuICAgICAgICAgIGl0ZW1zTGVmdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChvYnNlcnZlckluc3RhbmNlICYmICFpdGVtc0xlZnQpIHtcbiAgICAgIC8vIE5vIG1vcmUgZWxlbWVudHMgdG8gb2JzZXJ2ZSBmb3IgdGhyZXNob2xkLCBkaXNjb25uZWN0IG9ic2VydmVyXG4gICAgICBvYnNlcnZlckluc3RhbmNlLmRpc2Nvbm5lY3QoKTtcbiAgICAgIE9CU0VSVkVSX01BUC5kZWxldGUob2JzZXJ2ZXJJZCk7XG4gICAgfSAvLyBSZW1vdmUgcmVmZXJlbmNlIHRvIGVsZW1lbnRcblxuXG4gICAgSU5TVEFOQ0VfTUFQLmRlbGV0ZShlbGVtZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkNoYW5nZShjaGFuZ2VzKSB7XG4gIGNoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJzZWN0aW9uKSB7XG4gICAgdmFyIGlzSW50ZXJzZWN0aW5nID0gaW50ZXJzZWN0aW9uLmlzSW50ZXJzZWN0aW5nLFxuICAgICAgICBpbnRlcnNlY3Rpb25SYXRpbyA9IGludGVyc2VjdGlvbi5pbnRlcnNlY3Rpb25SYXRpbyxcbiAgICAgICAgdGFyZ2V0ID0gaW50ZXJzZWN0aW9uLnRhcmdldDtcbiAgICB2YXIgaW5zdGFuY2UgPSBJTlNUQU5DRV9NQVAuZ2V0KHRhcmdldCk7IC8vIEZpcmVmb3ggY2FuIHJlcG9ydCBhIG5lZ2F0aXZlIGludGVyc2VjdGlvblJhdGlvIHdoZW4gc2Nyb2xsaW5nLlxuXG4gICAgaWYgKGluc3RhbmNlICYmIGludGVyc2VjdGlvblJhdGlvID49IDApIHtcbiAgICAgIHZhciBvcHRpb25zID0gaW5zdGFuY2Uub3B0aW9ucztcbiAgICAgIHZhciBfaW5WaWV3ID0gZmFsc2U7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMudGhyZXNob2xkKSkge1xuICAgICAgICAvLyBJZiB0aHJlc2hvbGQgaXMgYW4gYXJyYXksIGNoZWNrIGlmIGFueSBvZiB0aGVtIGludGVyc2VjdHMuIFRoaXMganVzdCB0cmlnZ2VycyB0aGUgb25DaGFuZ2UgZXZlbnQgbXVsdGlwbGUgdGltZXMuXG4gICAgICAgIF9pblZpZXcgPSBvcHRpb25zLnRocmVzaG9sZC5zb21lKGZ1bmN0aW9uICh0aHJlc2hvbGQpIHtcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2UudmlzaWJsZSA/IGludGVyc2VjdGlvblJhdGlvID4gdGhyZXNob2xkIDogaW50ZXJzZWN0aW9uUmF0aW8gPj0gdGhyZXNob2xkO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy50aHJlc2hvbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBUcmlnZ2VyIG9uIDAgcmF0aW8gb25seSB3aGVuIG5vdCB2aXNpYmxlLiBUaGlzIGlzIGZhbGxiYWNrIGZvciBicm93c2VycyB3aXRob3V0IGlzSW50ZXJzZWN0aW5nIHN1cHBvcnRcbiAgICAgICAgX2luVmlldyA9IGluc3RhbmNlLnZpc2libGUgPyBpbnRlcnNlY3Rpb25SYXRpbyA+IG9wdGlvbnMudGhyZXNob2xkIDogaW50ZXJzZWN0aW9uUmF0aW8gPj0gb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ludGVyc2VjdGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIElmIGlzSW50ZXJzZWN0aW5nIGlzIGRlZmluZWQsIGVuc3VyZSB0aGF0IHRoZSBlbGVtZW50IGlzIGFjdHVhbGx5IGludGVyc2VjdGluZy5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGl0IHJlcG9ydHMgYSB0aHJlc2hvbGQgb2YgMFxuICAgICAgICBfaW5WaWV3ID0gX2luVmlldyAmJiBpc0ludGVyc2VjdGluZztcbiAgICAgIH1cblxuICAgICAgaW5zdGFuY2UudmlzaWJsZSA9IF9pblZpZXc7XG4gICAgICBpbnN0YW5jZS5jYWxsYmFjayhfaW5WaWV3LCBpbnRlcnNlY3Rpb25SYXRpbyk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlSW5WaWV3KHJlZiwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgLy8gJEZsb3dGaXhNZSAtIHVzZVN0YXRlIGlzIG5vdCBleHBvc2VkIGluIFJlYWN0IEZsb3cgbGliIHlldFxuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLFxuICAgICAgaXNJblZpZXcgPSBfUmVhY3QkdXNlU3RhdGVbMF0sXG4gICAgICBzZXRJblZpZXcgPSBfUmVhY3QkdXNlU3RhdGVbMV07IC8vICRGbG93Rml4TWUgLSB1c2VFZmZlY3QgaXMgbm90IGV4cG9zZWQgaW4gUmVhY3QgRmxvdyBsaWIgeWV0XG5cblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChyZWYuY3VycmVudCkge1xuICAgICAgb2JzZXJ2ZShyZWYuY3VycmVudCwgZnVuY3Rpb24gKGluVmlldykge1xuICAgICAgICBzZXRJblZpZXcoaW5WaWV3KTtcblxuICAgICAgICBpZiAoaW5WaWV3ICYmIG9wdGlvbnMudHJpZ2dlck9uY2UpIHtcbiAgICAgICAgICAvLyBJZiBpdCBzaG91bGQgb25seSB0cmlnZ2VyIG9uY2UsIHVub2JzZXJ2ZSB0aGUgZWxlbWVudCBhZnRlciBpdCdzIGluVmlld1xuICAgICAgICAgIHVub2JzZXJ2ZShyZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgdGhyZXNob2xkOiBvcHRpb25zLnRocmVzaG9sZCxcbiAgICAgICAgcm9vdDogb3B0aW9ucy5yb290LFxuICAgICAgICByb290TWFyZ2luOiBvcHRpb25zLnJvb3RNYXJnaW5cbiAgICAgIH0sIG9wdGlvbnMucm9vdElkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdW5vYnNlcnZlKHJlZi5jdXJyZW50KTtcbiAgICB9O1xuICB9LCBbb3B0aW9ucy50aHJlc2hvbGQsIG9wdGlvbnMucm9vdCwgb3B0aW9ucy5yb290TWFyZ2luLCBvcHRpb25zLnJvb3RJZF0pO1xuICByZXR1cm4gaXNJblZpZXc7XG59XG5cbi8qKlxuICogTW9uaXRvcnMgc2Nyb2xsLCBhbmQgdHJpZ2dlcnMgdGhlIGNoaWxkcmVuIGZ1bmN0aW9uIHdpdGggdXBkYXRlZCBwcm9wc1xuICpcbiA8SW5WaWV3PlxuIHsoe2luVmlldywgcmVmfSkgPT4gKFxuICAgPGgxIHJlZj17cmVmfT57YCR7aW5WaWV3fWB9PC9oMT5cbiApfVxuIDwvSW5WaWV3PlxuICovXG52YXIgSW5WaWV3ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKEluVmlldywgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gSW5WaWV3KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCBcInN0YXRlXCIsIHtcbiAgICAgIGluVmlldzogZmFsc2UsXG4gICAgICBpbnRlcnNlY3Rpb25SYXRpbzogMFxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCBcIm5vZGVcIiwgbnVsbCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSksIFwiaGFuZGxlTm9kZVwiLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKF90aGlzLm5vZGUpIHVub2JzZXJ2ZShfdGhpcy5ub2RlKTtcbiAgICAgIF90aGlzLm5vZGUgPSBub2RlO1xuXG4gICAgICBfdGhpcy5vYnNlcnZlTm9kZSgpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCBcImhhbmRsZUNoYW5nZVwiLCBmdW5jdGlvbiAoaW5WaWV3LCBpbnRlcnNlY3Rpb25SYXRpbykge1xuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpblZpZXc6IGluVmlldyxcbiAgICAgICAgaW50ZXJzZWN0aW9uUmF0aW86IGludGVyc2VjdGlvblJhdGlvXG4gICAgICB9KTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uQ2hhbmdlKSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uQ2hhbmdlKGluVmlldywgaW50ZXJzZWN0aW9uUmF0aW8pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEluVmlldy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmhhc093blByb3BlcnR5KCdyZW5kZXInKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJyZWFjdC1pbnRlcnNlY3Rpb24tb2JzZXJ2ZXI6IFxcXCJyZW5kZXJcXFwiIGlzIGRlcHJlY2F0ZWQsIGFuZCBzaG91bGQgYmUgcmVwbGFjZWQgd2l0aCBcXFwiY2hpbGRyZW5cXFwiXCIsIHRoaXMubm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGludmFyaWFudCh0aGlzLm5vZGUsIFwicmVhY3QtaW50ZXJzZWN0aW9uLW9ic2VydmVyOiBObyBET00gbm9kZSBmb3VuZC4gTWFrZSBzdXJlIHlvdSBmb3J3YXJkIFxcXCJyZWZcXFwiIHRvIHRoZSByb290IERPTSBlbGVtZW50IHlvdSB3YW50IHRvIG9ic2VydmUuXCIpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgLy8gSWYgYSBJbnRlcnNlY3Rpb25PYnNlcnZlciBvcHRpb24gY2hhbmdlZCwgcmVpbml0IHRoZSBvYnNlcnZlclxuICAgIGlmIChwcmV2UHJvcHMucm9vdE1hcmdpbiAhPT0gdGhpcy5wcm9wcy5yb290TWFyZ2luIHx8IHByZXZQcm9wcy5yb290ICE9PSB0aGlzLnByb3BzLnJvb3QgfHwgcHJldlByb3BzLnRocmVzaG9sZCAhPT0gdGhpcy5wcm9wcy50aHJlc2hvbGQpIHtcbiAgICAgIHVub2JzZXJ2ZSh0aGlzLm5vZGUpO1xuICAgICAgdGhpcy5vYnNlcnZlTm9kZSgpO1xuICAgIH1cblxuICAgIGlmIChwcmV2U3RhdGUuaW5WaWV3ICE9PSB0aGlzLnN0YXRlLmluVmlldykge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuaW5WaWV3ICYmIHRoaXMucHJvcHMudHJpZ2dlck9uY2UpIHtcbiAgICAgICAgdW5vYnNlcnZlKHRoaXMubm9kZSk7XG4gICAgICAgIHRoaXMubm9kZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLm5vZGUpIHtcbiAgICAgIHVub2JzZXJ2ZSh0aGlzLm5vZGUpO1xuICAgICAgdGhpcy5ub2RlID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9ic2VydmVOb2RlID0gZnVuY3Rpb24gb2JzZXJ2ZU5vZGUoKSB7XG4gICAgaWYgKCF0aGlzLm5vZGUpIHJldHVybjtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICB0aHJlc2hvbGQgPSBfdGhpcyRwcm9wcy50aHJlc2hvbGQsXG4gICAgICAgIHJvb3QgPSBfdGhpcyRwcm9wcy5yb290LFxuICAgICAgICByb290TWFyZ2luID0gX3RoaXMkcHJvcHMucm9vdE1hcmdpbixcbiAgICAgICAgcm9vdElkID0gX3RoaXMkcHJvcHMucm9vdElkO1xuICAgIG9ic2VydmUodGhpcy5ub2RlLCB0aGlzLmhhbmRsZUNoYW5nZSwge1xuICAgICAgdGhyZXNob2xkOiB0aHJlc2hvbGQsXG4gICAgICByb290OiByb290LFxuICAgICAgcm9vdE1hcmdpbjogcm9vdE1hcmdpblxuICAgIH0sIHJvb3RJZCk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wczIuY2hpbGRyZW4sXG4gICAgICAgIHJlbmRlciA9IF90aGlzJHByb3BzMi5yZW5kZXIsXG4gICAgICAgIHRhZyA9IF90aGlzJHByb3BzMi50YWcsXG4gICAgICAgIHRyaWdnZXJPbmNlID0gX3RoaXMkcHJvcHMyLnRyaWdnZXJPbmNlLFxuICAgICAgICB0aHJlc2hvbGQgPSBfdGhpcyRwcm9wczIudGhyZXNob2xkLFxuICAgICAgICByb290ID0gX3RoaXMkcHJvcHMyLnJvb3QsXG4gICAgICAgIHJvb3RJZCA9IF90aGlzJHByb3BzMi5yb290SWQsXG4gICAgICAgIHJvb3RNYXJnaW4gPSBfdGhpcyRwcm9wczIucm9vdE1hcmdpbixcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wczIsIFtcImNoaWxkcmVuXCIsIFwicmVuZGVyXCIsIFwidGFnXCIsIFwidHJpZ2dlck9uY2VcIiwgXCJ0aHJlc2hvbGRcIiwgXCJyb290XCIsIFwicm9vdElkXCIsIFwicm9vdE1hcmdpblwiXSk7XG5cbiAgICB2YXIgX3RoaXMkc3RhdGUgPSB0aGlzLnN0YXRlLFxuICAgICAgICBpblZpZXcgPSBfdGhpcyRzdGF0ZS5pblZpZXcsXG4gICAgICAgIGludGVyc2VjdGlvblJhdGlvID0gX3RoaXMkc3RhdGUuaW50ZXJzZWN0aW9uUmF0aW87XG4gICAgdmFyIHJlbmRlck1ldGhvZCA9IGNoaWxkcmVuIHx8IHJlbmRlcjtcblxuICAgIGlmICh0eXBlb2YgcmVuZGVyTWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcmVuZGVyTWV0aG9kKHtcbiAgICAgICAgaW5WaWV3OiBpblZpZXcsXG4gICAgICAgIGludGVyc2VjdGlvblJhdGlvOiBpbnRlcnNlY3Rpb25SYXRpbyxcbiAgICAgICAgcmVmOiB0aGlzLmhhbmRsZU5vZGVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHRhZyB8fCAnZGl2JywgX2V4dGVuZHMoe1xuICAgICAgcmVmOiB0aGlzLmhhbmRsZU5vZGVcbiAgICB9LCBwcm9wcyksIGNoaWxkcmVuKTtcbiAgfTtcblxuICByZXR1cm4gSW5WaWV3O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5fZGVmaW5lUHJvcGVydHkoSW5WaWV3LCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gIHRocmVzaG9sZDogMCxcbiAgdHJpZ2dlck9uY2U6IGZhbHNlXG59KTtcblxuZXhwb3J0cy5JblZpZXcgPSBJblZpZXc7XG5leHBvcnRzLmRlZmF1bHQgPSBJblZpZXc7XG5leHBvcnRzLnVzZUluVmlldyA9IHVzZUluVmlldztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/../../node_modules/.pnpm/react-intersection-observer@6.4.2_react@19.1.0/node_modules/react-intersection-observer/dist/react-intersection-observer.cjs.js\n");

/***/ })

};
;